--- a/background.js
+++ b/background.js
@@ -243,6 +243,7 @@
                     chrome.storage.local.set({ openTimes });
                     findSessionIdForUrl(url).then((sessionId) => {
                       addToHistory(url, title, { sessionId, prev });
+                      notifyClosedTabByEmailWebFlow(title, url);
                       incrementBadgeCount();
                       notifyClosed(url, title, { sessionId, prev });
                     }).finally(() => {
@@ -451,6 +452,21 @@
 // Popup communication for history and badge
 chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   if (!msg || !msg.type) return;
+  if (msg.type === 'gmail-connect' || msg.type === 'gmail-send') {
+    (async () => {
+      if (msg.type === 'gmail-connect') {
+        await oauthWithWebAuthFlow();
+        sendResponse({ ok: true });
+        return;
+      }
+      if (msg.type === 'gmail-send') {
+        await sendEmailViaGmailWebFlow(msg.payload || {}, { interactiveIfNeeded: true });
+        sendResponse({ ok: true });
+        return;
+      }
+    })().catch(err => sendResponse({ ok: false, error: String(err.message || err) }));
+    return true;
+  }
   if (msg.type === "getClosedHistory") {
   chrome.storage.local.get(["closedHistory", "badgeCount"], (data) => {
       sendResponse({
@@ -519,3 +535,175 @@
         chrome.storage.local.set({ undoMap }, () => resolve());
       });
     }));
 }
+
+// =================== Gmail via launchWebAuthFlow ===================
+
+// TODO: вставьте ваш OAuth Web Client ID:
+const OAUTH_WEB_CLIENT_ID = 'YOUR_WEB_CLIENT_ID.apps.googleusercontent.com';
+
+// Единственный скоуп: отправка писем
+const OAUTH_SCOPE = 'https://www.googleapis.com/auth/gmail.send';
+const GMAIL_SEND_URL = 'https://gmail.googleapis.com/gmail/v1/users/me/messages/send';
+
+// --- utils: MIME / кодировки ---
+function encodeRFC2047(str) {
+  const bytes = new TextEncoder().encode(str || '');
+  let bin = '';
+  for (const b of bytes) bin += String.fromCharCode(b);
+  const b64 = btoa(bin);
+  return `=?UTF-8?B?${b64}?=`;
+}
+
+function base64UrlEncodeUtf8(str) {
+  const bytes = new TextEncoder().encode(str);
+  let bin = '';
+  for (const b of bytes) bin += String.fromCharCode(b);
+  return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
+}
+
+function escapeHtml(s) {
+  return String(s)
+    .replace(/&/g, '&amp;').replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
+}
+
+// multipart/alternative (plain + html). Вложений пока нет.
+function buildMime({ to, subject, text, html, replyTo }) {
+  const boundary = 'ALT-' + Math.random().toString(36).slice(2);
+  const headers = [
+    `To: ${to}`,
+    `Subject: ${encodeRFC2047(subject || '')}`,
+    `MIME-Version: 1.0`,
+    `Content-Type: multipart/alternative; boundary="${boundary}"`,
+    replyTo ? `Reply-To: ${replyTo}` : null,
+    `Date: ${new Date().toUTCString()}`
+  ].filter(Boolean);
+
+  const parts = [
+    `--${boundary}`,
+    `Content-Type: text/plain; charset=UTF-8`,
+    ``,
+    (text ?? (html ? html.replace(/<[^>]+>/g, ' ').trim() : '')),
+    `--${boundary}`,
+    `Content-Type: text/html; charset=UTF-8`,
+    ``,
+    (html ?? (text ? `<pre>${escapeHtml(text)}</pre>` : '')),
+    `--${boundary}--`,
+    ``
+  ];
+
+  return headers.join('\r\n') + '\r\n\r\n' + parts.join('\r\n');
+}
+
+async function safeJson(res) {
+  try { return await res.json(); } catch { return null; }
+}
+
+// --- OAuth (implicit) через launchWebAuthFlow ---
+async function oauthWithWebAuthFlow() {
+  const redirectUri = chrome.identity.getRedirectURL(); // https://<ext_id>.chromiumapp.org/
+  const scope = encodeURIComponent(OAUTH_SCOPE);
+  const state = Math.random().toString(36).slice(2);
+
+  const authUrl =
+    'https://accounts.google.com/o/oauth2/v2/auth' +
+    `?client_id=${encodeURIComponent(OAUTH_WEB_CLIENT_ID)}` +
+    `&response_type=token` +
+    `&redirect_uri=${encodeURIComponent(redirectUri)}` +
+    `&scope=${scope}` +
+    `&include_granted_scopes=true` +
+    `&prompt=select_account%20consent` +
+    `&state=${state}`;
+
+  const redirectedTo = await new Promise((resolve, reject) => {
+    chrome.identity.launchWebAuthFlow({ url: authUrl, interactive: true }, (url) => {
+      if (chrome.runtime.lastError || !url) {
+        reject(new Error(chrome.runtime.lastError?.message || 'Auth canceled'));
+      } else {
+        resolve(url);
+      }
+    });
+  });
+
+  const hash = new URL(redirectedTo).hash.slice(1);
+  const params = new URLSearchParams(hash);
+  if (params.get('state') !== state) throw new Error('Bad state');
+
+  const accessToken = params.get('access_token');
+  const expiresIn = Number(params.get('expires_in') || 3600);
+  if (!accessToken) throw new Error('No access_token');
+
+  await chrome.storage.local.set({
+    gmailAccessToken: accessToken,
+    gmailAccessTokenExp: Date.now() + (expiresIn - 60) * 1000
+  });
+
+  return accessToken;
+}
+
+async function getStoredAccessToken() {
+  const { gmailAccessToken, gmailAccessTokenExp } = await chrome.storage.local.get([
+    'gmailAccessToken', 'gmailAccessTokenExp'
+  ]);
+  if (gmailAccessToken && gmailAccessTokenExp > Date.now()) return gmailAccessToken;
+  return null;
+}
+
+async function getAccessTokenWebFlow({ interactiveIfNeeded = false } = {}) {
+  const cached = await getStoredAccessToken();
+  if (cached) return cached;
+  if (!interactiveIfNeeded) throw new Error('Not authorized');
+  return oauthWithWebAuthFlow();
+}
+
+async function gmailSendRawViaWebFlow(raw, { interactiveIfNeeded = false } = {}) {
+  let token = await getAccessTokenWebFlow({ interactiveIfNeeded });
+  let res = await fetch(GMAIL_SEND_URL, {
+    method: 'POST',
+    headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
+    body: JSON.stringify({ raw })
+  });
+
+  if (res.status === 401) {
+    await chrome.storage.local.remove(['gmailAccessToken', 'gmailAccessTokenExp']);
+    if (!interactiveIfNeeded) {
+      const err = await safeJson(res);
+      throw new Error(err?.error?.message || 'Unauthorized');
+    }
+    token = await oauthWithWebAuthFlow();
+    res = await fetch(GMAIL_SEND_URL, {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
+      body: JSON.stringify({ raw })
+    });
+  }
+
+  if (!res.ok) {
+    const err = await safeJson(res);
+    throw new Error(err?.error?.message || `Gmail send failed: ${res.status}`);
+  }
+  return await res.json();
+}
+
+async function sendEmailViaGmailWebFlow({ to, subject, text, html, replyTo }, { interactiveIfNeeded = false } = {}) {
+  if (!to) throw new Error('Missing "to"');
+  const mime = buildMime({ to, subject, text, html, replyTo });
+  const raw = base64UrlEncodeUtf8(mime);
+  return gmailSendRawViaWebFlow(raw, { interactiveIfNeeded });
+}
+
+// Вызывается при закрытии вкладки (тихо, без интерактива)
+async function notifyClosedTabByEmailWebFlow(title, url) {
+  try {
+    const { notifyEmail } = await chrome.storage.sync.get('notifyEmail');
+    if (!notifyEmail) return;
+    await sendEmailViaGmailWebFlow({
+      to: notifyEmail,
+      subject: `Closed: ${title || url}`,
+      text: `Closed as unread: ${url}`,
+      html: `<b>Closed as unread</b><br><a href="${escapeHtml(url)}">${escapeHtml(url)}</a>`
+    }, { interactiveIfNeeded: false });
+  } catch (e) {
+    // тихая деградация
+  }
+}
